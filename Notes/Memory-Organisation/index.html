<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=description content="Memory Organisation Virtual Memory The idea behind virtual memory is to abstract away the memory addresses from the underlying physical storage device."><title>Memory Organisation
</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script><script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script><script src=https://unpkg.com/@floating-ui/core@0.7.3></script><script src=https://unpkg.com/@floating-ui/dom@0.5.4></script><script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script><script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script><script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script><script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script><script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.84a6714a5001f23f619a6012b456b34d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.61de53cbb96862628149d53bfdffe9d4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{"’":"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script><script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg>
</label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Memory Organisation</h1><p class=meta>Last updated
Nov 8, 2022
<a href=https://github.com/bbawj/site/Notes/Memory%20Organisation.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#virtual-memory>Virtual Memory</a></li><li><a href=#address-binding>Address Binding</a></li><li><a href=#fragmentation>Fragmentation</a></li></ol><ol><li><a href=#contiguous-allocation>Contiguous allocation</a><ol><li><a href=#fixed-partitioning>Fixed partitioning</a></li><li><a href=#dynamic-partitioning>Dynamic partitioning</a></li><li><a href=#dynamic-allocation-policies>Dynamic Allocation Policies</a></li><li><a href=#problems>Problems</a></li></ol></li><li><a href=#segmentation-non-contiguous-allocation>Segmentation (Non Contiguous Allocation)</a><ol><li><a href=#addressing>Addressing</a></li><li><a href=#problems-1>Problems</a></li></ol></li><li><a href=#paging>Paging</a><ol><li><a href=#fragmentation-1>Fragmentation</a></li><li><a href=#address-translation>Address Translation</a></li><li><a href=#hardware-support>Hardware Support</a></li><li><a href=#shared-pages>Shared Pages</a></li><li><a href=#multi-level-paging>Multi-level Paging</a></li><li><a href=#inverted-page-table>Inverted Page Table</a></li><li><a href=#accessing-page-tables>Accessing Page Tables</a></li></ol></li><li><a href=#practice-problems>Practice Problems</a></li></ol></nav></details></aside><a href=#memory-organisation><h1 id=memory-organisation><span class=hanchor arialabel=Anchor># </span>Memory Organisation</h1></a><a href=#virtual-memory><h2 id=virtual-memory><span class=hanchor arialabel=Anchor># </span>Virtual Memory</h2></a><p>The idea behind virtual memory is to abstract away the memory addresses from the underlying physical storage device. Instead of directly accessing the storage device, a translation step is performed first. For segmentation, the translation step is to add the offset address of the active segment. Imagine a program accessing memory address 0x1234000 in a segment with an offset of 0x1111000: The address that is really accessed is 0x2345000.</p><p>This allows both programs to run the same code and use the same virtual addresses without interfering with each other:
<img src=https://i.imgur.com/env7uVA.png width=auto alt></p><a href=#address-binding><h2 id=address-binding><span class=hanchor arialabel=Anchor># </span>Address Binding</h2></a><p>A program needs to be loaded into memory to run. The machine code that is generated needs to be mapped to memory addresses in the system.
<img src=https://i.imgur.com/zbwjCpb.png width=auto alt>
Possible binding stages:</p><ol><li>Compile time: memory location is known a priori, generating <strong>absolute code</strong> that must be recompiled if the starting location changes</li><li>Load time: compiler generates <strong>relocatable code</strong> and the binding is performed by the loader.
<img src=https://i.imgur.com/48kWnKH.png width=auto alt></li><li>Execution time: binding is delayed until run time and the process can be moved during its execution from one memory segment to another. Uses a logical address that is relative to a starting 0 point.
<img src=https://i.imgur.com/RAMNzgU.png width=auto alt></li></ol><a href=#fragmentation><h2 id=fragmentation><span class=hanchor arialabel=Anchor># </span>Fragmentation</h2></a><blockquote class="[! ]-callout"><p>[! ]
Internal Fragmentation: allocated memory may be larger than requested memory, this results in unusable memory within the partition</p><p>External Fragmentation : unusable memory between partitions</p></blockquote><a href=#memory-allocation><h1 id=memory-allocation><span class=hanchor arialabel=Anchor># </span>Memory Allocation</h1></a><p>How to assign memory to different processes?</p><a href=#contiguous-allocation><h2 id=contiguous-allocation><span class=hanchor arialabel=Anchor># </span>Contiguous allocation</h2></a><p>Logical address space of process remains contiguous in physical memory.
<img src=https://i.imgur.com/ZKxu4vz.png width=auto alt></p><a href=#fixed-partitioning><h3 id=fixed-partitioning><span class=hanchor arialabel=Anchor># </span>Fixed partitioning</h3></a><p>Memory is partitioned into regions with fixed boundaries. OS decides which partition to assign a process to depending on the available partitions.
<img src=https://i.imgur.com/8l3OiKG.png width=auto alt=400x400>
<em>Internal fragmentation</em>: as each partition is fixed, a process assigned to a partition might not take up the entire space of the partition, resulting in wasted unusable memory internal to the partition.</p><a href=#dynamic-partitioning><h3 id=dynamic-partitioning><span class=hanchor arialabel=Anchor># </span>Dynamic partitioning</h3></a><p>Do not partition the memory. Rather, the OS allocates the exact chunk of memory which a process requires, and keeps tracks of <em>holes</em> or available blocks of memory.
<img src=https://i.imgur.com/vEdUH9c.png width=auto alt>
<em>External fragmentation</em>: memory space between partitions (the holes) may be enough to satisfy a new request but is not contiguous and cannot be used. This can be solved by performing compaction, which shuffles memory contents to produce contiguous block of available memory.</p><a href=#dynamic-allocation-policies><h3 id=dynamic-allocation-policies><span class=hanchor arialabel=Anchor># </span>Dynamic Allocation Policies</h3></a><p><img src=https://i.imgur.com/QYCVh9D.png width=auto alt></p><a href=#problems><h3 id=problems><span class=hanchor arialabel=Anchor># </span>Problems</h3></a><p>In contiguous allocation, the entire address space of process memory is kept together. This causes a big chunk of &ldquo;free space&rdquo; that lies between the stack and heap of a process which is wasted <em>(internal fragmentation)</em>.
<img src=https://i.imgur.com/I1HB0Q6.png width=auto alt=300></p><a href=#segmentation-non-contiguous-allocation><h2 id=segmentation-non-contiguous-allocation><span class=hanchor arialabel=Anchor># </span>Segmentation (Non Contiguous Allocation)</h2></a><p><img src=https://i.imgur.com/r7Z4FUg.png width=auto alt></p><a href=#addressing><h3 id=addressing><span class=hanchor arialabel=Anchor># </span>Addressing</h3></a><p><img src=https://i.imgur.com/eTJ6naG.png width=auto alt></p><p><img src=https://i.imgur.com/KECm1QL.png width=auto alt></p><blockquote class=faq-callout><p>Segmentation Fault
What if we try to refer to an illegal address? The hardware detects that the address is out of bounds, traps into the OS, likely leading to the termination of the offending process. That is called a segmentation fault.</p></blockquote><a href=#problems-1><h3 id=problems-1><span class=hanchor arialabel=Anchor># </span>Problems</h3></a><ul><li><em>External fragmentation</em>: as processes leave the system, occupied segments become holes in the memory</li><li>Segmentation still isn’t flexible enough to support our fully generalized, sparse address space. For example, if we have a large but sparsely-used heap all in one logical segment, the entire heap must still reside in memory in order to be accessed. In other words, if our model of how the address space is being used doesn’t exactly match how the underlying segmentation has been designed to support it, segmentation doesn’t work very well</li></ul><a href=#paging><h2 id=paging><span class=hanchor arialabel=Anchor># </span>Paging</h2></a><p>^b8969e</p><blockquote class=[!idea:]-callout><p>[!Idea:]</p><ol><li>Divide the physical memory into fixed sized <em>frames</em>.</li><li>Divide logical memory of the <strong>process</strong> into <em>pages</em> the same size as frames.</li><li>Use a page table to map the logical memory to physical memory.
<img src=https://os.phil-opp.com/paging-introduction/paging-fragmentation.svg width=auto alt></li></ol></blockquote><a href=#fragmentation-1><h3 id=fragmentation-1><span class=hanchor arialabel=Anchor># </span>Fragmentation</h3></a><ul><li>Eliminating external fragmentation as every available physical memory space can be utilised.</li><li>Internal fragmentation still possible as the last page may not use up the entire frame.</li></ul><a href=#address-translation><h3 id=address-translation><span class=hanchor arialabel=Anchor># </span>Address Translation</h3></a><p>Split the logical address to map page to frame:
<img src=https://i.imgur.com/3pFbZJN.png width=auto alt>
Offset necessary to locate the byte-addressable piece of physical memory.
<img src=https://i.imgur.com/QPaWk69.png width=auto alt>
<img src=https://i.imgur.com/zOHdEXK.png width=auto alt></p><a href=#hardware-support><h3 id=hardware-support><span class=hanchor arialabel=Anchor># </span>Hardware Support</h3></a><p>The page table is stored in main memory with a page table base register (PTBR) pointing to it.</p><a href=#translation-look-aside-buffers-tlb><h4 id=translation-look-aside-buffers-tlb><span class=hanchor arialabel=Anchor># </span>Translation Look-aside Buffers (TLB)</h4></a><p>The page table is stored in memory and thus, to access a piece of physical memory, we require 1 memory access to the page table and 1 memory access to the actual memory. We can speed this up with a specialised cache for the page table.
<img src=https://i.imgur.com/YdHgJgB.png width=auto alt></p><a href=#effective-access-time><h4 id=effective-access-time><span class=hanchor arialabel=Anchor># </span>Effective access time</h4></a><p>With TLB:</p><ul><li>1 TLB access and 1 mem access on hit</li><li>1 TLB access and 2 mem access on miss
<img src=https://i.imgur.com/C0yZp2Q.png width=auto alt></li></ul><a href=#shared-pages><h3 id=shared-pages><span class=hanchor arialabel=Anchor># </span>Shared Pages</h3></a><p>Reentrant or code which never changes during execution can be shared among processes by having processes used the same pages.
<img src=https://i.imgur.com/A6xWe1W.png width=auto alt=500x500></p><a href=#multi-level-paging><h3 id=multi-level-paging><span class=hanchor arialabel=Anchor># </span>Multi-level Paging</h3></a><blockquote class=idea-callout><p>A page table can be large. Not efficient to have to fetch the entire page table for every memory LOAD/STUR instruction.
<img src=https://i.imgur.com/7pH5hvu.png width=auto alt>
The multi-level table only allocates page-table space in proportion to the amount of address space you are using (a linear page table would require the whole thing to reside in memory to correctly perform address translation); thus it is generally compact and supports sparse address spaces.
<img src=https://i.imgur.com/ndkJ3sD.png width=auto alt></p></blockquote><a href=#paging-the-page-table><h4 id=paging-the-page-table><span class=hanchor arialabel=Anchor># </span>Paging the page table</h4></a><p><img src=https://i.imgur.com/Xllezzl.png width=auto alt></p><ul><li>Final level represents the physical memory space, 12 bits is needed for byte-addressing the 4KB memory. This leaves 20 bits for indexing pages.</li><li>Second level represents the index to the first level page: There are $2^{20}$ pages. Each page in this level is 4 bytes so as to map to the address of a 4byte page address.</li><li>The root level represents the index to the 2nd level page: Since 1 block can store 4KB, to store information about the 4MB page table in 1 block will require $2^{20}\times4/2^{12}=2^{10}$ entries
Hence, 10 bits to access 1 out of $2^{10}$ pages which itself contains 10 bits to access 1 out of $2^{10}$ pages. Total of $2^{20}$ pages.
<img src=https://i.imgur.com/dhOBFTt.png width=auto alt></li></ul><blockquote class=faq-callout><p>Trade-offs
On a TLB miss, two loads from memory will be required to get the right translation information from the page table (one for the page directory, and one for the PTE itself</p></blockquote><a href=#inverted-page-table><h3 id=inverted-page-table><span class=hanchor arialabel=Anchor># </span>Inverted Page Table</h3></a><blockquote class="[! idea:]-callout"><p>[! Idea:]
Rather than each process having its own page table, we only keep a single table with 1 entry for each physical frame.</p><ol><li>Each entry contains the <code>process-id</code> and <code>page-number</code></li><li>To find a matching entry for a logical address, we need to find the entry that has the equivalent proces_id and page_number pair</li></ol></blockquote><p><img src=https://i.imgur.com/1syY6Pr.png width=auto alt>
We gain in terms of memory, as we no longer have a page table size that is proportional to logical addressing space. We lose in terms of speed, as we need to search the page table rather than addressing it directly with a page index.</p><a href=#accessing-page-tables><h3 id=accessing-page-tables><span class=hanchor arialabel=Anchor># </span>Accessing Page Tables</h3></a><p>Most operating systems kernels run with paging enabled. This means that memory accesses in the kernel are inherently through virtual addresses. This is good, since programs could easily circumvent memory protection and access the memory of other programs otherwise. So the only way to access some physical address is through some virtual page that is mapped to the physical frame at address.</p><a href=#identity-mapping><h4 id=identity-mapping><span class=hanchor arialabel=Anchor># </span>Identity mapping</h4></a><p>This way, the physical addresses of page tables are also valid virtual addresses so that we can easily access the page tables of all levels
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230709115655.png width=auto alt=png>
However, it clutters the virtual address space and makes it more difficult to find continuous memory regions of larger sizes i.e. fragmentation.</p><a href=#fixed-offset-mapping><h4 id=fixed-offset-mapping><span class=hanchor arialabel=Anchor># </span>Fixed offset mapping</h4></a><p>We can <strong>use a separate memory region for page table mappings</strong>, for example, at 10 TiB:
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230709224247.png width=auto alt=png>
However, this means we still have to create a new mapping whenever we create a new page table.</p><a href=#map-the-complete-physical-memory><h4 id=map-the-complete-physical-memory><span class=hanchor arialabel=Anchor># </span>Map the complete physical memory</h4></a><p>This approach allows our kernel to access arbitrary physical memory, including page table frames of other address spaces. The reserved virtual memory range has the same size as before, with the difference that it no longer contains unmapped pages.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230709224610.png width=auto alt=png>
However, additional page tables are needed for storing the mapping of the physical memory. These page tables need to be stored somewhere, so they use up a part of physical memory, which can be a problem on devices with a small amount of memory.</p><a href=#practice-problems><h2 id=practice-problems><span class=hanchor arialabel=Anchor># </span>Practice Problems</h2></a><p><img src=https://i.imgur.com/YwvOJ6S.png width=auto alt></p><p><img src=https://www.brendanang.dev//Pics/Memory%20Organisation%202022-10-10%2023.41.06.excalidraw.md width=auto alt=600>
c. First fit lower overhead. Only moved 1 block compared to 3 blocks in best fit.
<img src=https://i.imgur.com/mv4UR97.png width=auto alt>
a. Fixed partitioning
b. Process memory is based on absolute addresses and is unable to be relocated for memory compaction.
<img src=https://i.imgur.com/exWOYRb.png width=auto alt>
a. 200ns to access the page table. Another 200ns to access the memory frame. Total time: 400ns
b. $$\text{Total time}=0.75\times200+0.25\times400=250ns$$
<img src=https://i.imgur.com/2Wu9M80.png width=auto alt>
a.
To address a byte in a 1-Kbyte page will require 10 bits
Logical address: 22 bit page index, 10 bit offset
1 Gigabyte ($2^{30}$) physical memory will require, 30 bits to represent each byte address
<img src=https://i.imgur.com/bD0lkow.png width=auto alt>
b.
$2^{22}$ pages.
c.
Number of entries = Number of physical frames: $2^{30}/2^{10}=2^{20}$
<img src=https://i.imgur.com/zciAu6J.png width=auto alt>
a.
There are 8 pages, 3 bits are required to determine the page index.
Remaining 7 bits are used for the page offset, to address the individual byte in the page.
1000011011 -> Page 100 Offset 0011011 -> Page = 4 -> Frame number 01001
Physical address: $010010011011$
b.
There are 4 segments, 2 bits required to determine segment number
Remaining 8 bits used to address the physical memory unit
1000011011 -> Segment 10 Offset 00011011 -> Segment = 2
<img src=https://i.imgur.com/873Y5nz.png width=auto alt></p><p><img src=https://i.imgur.com/M0XVmUz.png width=auto alt>
a.
Number of pages = $2^{30}/1024=2^{20}$
Size of table = $2^{20}\times4=2^{22}$
b.
$$
\begin{align}
&\text{Size of page table 1st level}=2^{22}\\ &\text{Number of pages 2nd level}=2^{22}/2^{10}=2^{12}\\ &\text{Size of 2nd level}=2^{12}\times4=2^{14}\\ &\text{Number of pages 3rd level}=2^{14}/2^{10}=2^4\\ &\text{Size of 3rd level}=2^4\times4=2^6&lt;1024B\\ &\text{Total no. of levels}=3
\end{align}
$$
c.
3rd level holds $2^4$ pages and requires 4 bits to index
Each page table can hold $2^{10}/2^2=2^8$ entries
8 bits needed to index into the 2nd level
Each page table in the 2nd level holds $2^8$ entries
8 bits needed to index into the final level
<img src=https://i.imgur.com/tIVXHKn.png width=auto alt></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/2005-Operating-Systems/ data-ctx="Memory Organisation" data-src=/2005-Operating-Systems class=internal-link>2005 Operating Systems</a></li><li><a href=/Notes/Allocators/ data-ctx=Paging data-src=/Notes/Allocators class=internal-link>Allocators</a></li><li><a href=/Notes/File-Systems/ data-ctx="page table" data-src=/Notes/File-Systems class=internal-link>File Systems</a></li><li><a href=/Notes/Virtual-Memory/ data-ctx="memory organisation" data-src=/Notes/Virtual-Memory class=internal-link>Virtual Memory</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2025</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>