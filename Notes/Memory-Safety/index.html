<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=description content="Safe memory access is when each memory location that is used must have been
allocated (statically, on stack, or on heap), initialized (write before read)."><title>Memory Safety
</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script><script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script><script src=https://unpkg.com/@floating-ui/core@0.7.3></script><script src=https://unpkg.com/@floating-ui/dom@0.5.4></script><script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script><script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script><script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script><script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script><script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.84a6714a5001f23f619a6012b456b34d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.61de53cbb96862628149d53bfdffe9d4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{"’":"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script><script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg>
</label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Memory Safety</h1><p class=meta>Last updated
May 11, 2023
<a href=https://github.com/bbawj/site/Notes/Memory%20Safety.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#buffer-overflow>Buffer Overflow</a><ol><li><a href=#compiler-support>Compiler Support</a></li><li><a href=#os-support>OS Support</a></li></ol></li><li><a href=#memory-leaks>Memory Leaks</a></li><li><a href=#memory-checking-tools>Memory Checking Tools</a><ol><li><a href=#input-generation>Input generation</a></li></ol></li></ol></nav></details></aside><p>Safe memory access is when each memory location that is used must have been</p><ul><li>allocated (statically, on stack, or on heap),</li><li>initialized (write before read).</li><li>dynamically allocated memory must be freed exactly once.</li><li>No memory exhaustion.</li></ul><a href=#memory-corruption><h1 id=memory-corruption><span class=hanchor arialabel=Anchor># </span>Memory Corruption</h1></a><p>Exploited to get access to protected data, or overwrite important data that governs control flow; may hijack process:</p><ol><li>Access to an unallocated memory region, or a region outside given buffer.</li><li>May read uninitialized memory, or write to memory used by other buffer.</li></ol><a href=#buffer-overflow><h2 id=buffer-overflow><span class=hanchor arialabel=Anchor># </span>Buffer Overflow</h2></a><p><img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230911011103.png width=auto alt>
A variant of buffer overflow is Stack Smashing, or stack buffer overflow. Following the above C code we can overwrite the return address on the frame with address to malicious program:
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230920231925.png width=auto alt=200x300>
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230920232012.png width=auto alt=200x300></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;  </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>overflow</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>input</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Virtual address of &#39;buf&#39; = Ox%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=nf>strcpy</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>input</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>attack</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;&#39;attack’ is called without explicitly invocation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Buffer Overflow attack succeeded!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Virtual address of &#39;overflow&#39; = Ox%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>overflow</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Virtual address of &#39;attack&#39; = Ox%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>attack</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>input</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;...&#34;</span><span class=p>;</span> <span class=cm>/* useless content as offset*/</span>  
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>add</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;</span><span class=se>\xf9\x51\x55\x55\x55\x55</span><span class=s>&#34;</span><span class=p>;</span> <span class=cm>/* attack address*/</span>  
</span></span><span class=line><span class=cl>	<span class=nf>strcat</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>add</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=nf>overflow</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Needs the absolute address of malicious code which can be infeasible. By inserting NOP instructions before the malicious code, it can improve the guess chance by allowing the program to advance until the address of the malicious program.</p><a href=#compiler-support><h3 id=compiler-support><span class=hanchor arialabel=Anchor># </span>Compiler Support</h3></a><a href=#stack-guard><h4 id=stack-guard><span class=hanchor arialabel=Anchor># </span>Stack Guard</h4></a><p>Key insight: difficult to modify the return address without overwriting stack memory in front of the return address. Generate a canary next to the return address and check it whenever a function returns:
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230920233534.png width=auto alt>
Random Canary</p><ul><li>Choose random string at program startup</li><li>Insert canary string into every stack frame.</li><li>Verify canary before returning from function. If canary value is changed, then exit program (potential Denial-of-Service attack)</li><li>To corrupt, attacker must learn current random string
Terminator canary.</li><li>Canary = {\0, newline, linefeed, EOF}</li><li>String functions will not copy beyond terminator</li><li>Attacker cannot use string functions to corrupt stack.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230921003100.png width=auto alt></li></ul><a href=#point-guard><h4 id=point-guard><span class=hanchor arialabel=Anchor># </span>Point Guard</h4></a><p>Protect the pointers from being overwritten with more performance overhead:</p><ul><li>Encrypt all pointers while in memory</li><li>Generate a random key when program is executed</li><li>Each pointer is XORed with this key when stored into memory</li><li>Attacker cannot predict the target program’s key. Even if the pointer is overwritten, after XORing with the key it will point to a “random” memory address. This can prevent the execution of malicious functions, but can crash the program</li></ul><a href=#stack-shield><h4 id=stack-shield><span class=hanchor arialabel=Anchor># </span>Stack Shield</h4></a><p>A GNU C compiler extension that protects the return address by separating the return address from data.</p><ul><li>Copy the return address to a non-overflowable area</li><li>Restore the return address when returning from a function, altered return addresses on the stack will have no effect.</li></ul><a href=#os-support><h3 id=os-support><span class=hanchor arialabel=Anchor># </span>OS Support</h3></a><a href=#address-space-layout-randomization><h4 id=address-space-layout-randomization><span class=hanchor arialabel=Anchor># </span>Address Space Layout Randomization</h4></a><p>OS randomly arranges address space of key data areas for each program such as the base, stack, heap and library pointers, which makes guessing malicious program address harder.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230921003943.png width=auto alt></p><a href=#non-executable-memory><h4 id=non-executable-memory><span class=hanchor arialabel=Anchor># </span>Non-executable Memory</h4></a><p>Executable memory regions allow attackers to inject a binary payload
For example, a simple way to obtaining shell access:
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230911011702.png width=auto alt>
Mark all writable memory locations as non-executable. Some examples are ExecShield in Linux.
Code reuse attacks make use of already loaded functions, for example overwriting the return address to libc <code>execve</code> with <code>/bin/sh</code> as an argument.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230921004246.png width=auto alt></p><a href=#shadow-stack><h4 id=shadow-stack><span class=hanchor arialabel=Anchor># </span>Shadow Stack</h4></a><p>Keep a copy of the stack in memory. Compare the actual and shadow stack to see if the return address has been changed.</p><a href=#hardware-support><h4 id=hardware-support><span class=hanchor arialabel=Anchor># </span>Hardware Support</h4></a><p>ARM Memory Tagging Extension (MTE):</p><ul><li>Every memory pointer and user memory region has a 4 bit-tag. These tags must match when reading from the pointer. Else, a hardware exception is raised.</li></ul><p>Hardware can support an attribute in the Page Table Entry to control if the page is executable.</p><a href=#memory-leaks><h2 id=memory-leaks><span class=hanchor arialabel=Anchor># </span>Memory Leaks</h2></a><p>A serious issue for long running programs.</p><p>Allocated memory is not freed but also never used again:</p><ol><li>Lost for good: memory is no longer reachable, perhaps due to losing the only pointer to that memory. May be garbage collected.</li><li>Potentially lost: memory is still reachable (the program still holds a pointer), and hence may not be garbage collected.</li></ol><a href=#memory-checking-tools><h2 id=memory-checking-tools><span class=hanchor arialabel=Anchor># </span>Memory Checking Tools</h2></a><p>Popular tool:
<a href=http://valgrind.org/ rel=noopener>valgrind</a>.</p><ul><li>Mature memory checker, used in many projects.</li><li>Finds any problems related to heap-allocated memory and some stack allocated cases.</li></ul><a href=#input-generation><h3 id=input-generation><span class=hanchor arialabel=Anchor># </span>Input generation</h3></a><p>These tools use different inputs to attempt to find one which can cause a memory error.</p><ul><li>Unit testing: able to model specific input sequences but difficult to cover many inpits</li><li>Random testing: automatically generate many inputs but can still result in shallow coverage if the specific input format is not followed (by generating alot of noise that is not relevant to the program).</li><li>Fuzz testing: generates many <em>slightly invalid</em> inputs based on format of valid examples.<ul><li>Mutation based: explore as many states as possible by changing inputs randomly, possibly guided by heuristics from an initial corpus of data. These are simple to set up but have low coverage.</li><li>Generative: use specification of input format (RFC etc.) into a generative procedure to make use of domain-specific knowledge but requires more effort</li><li>Coverage guided: use fuzzing to create new test cases. Test and measure code coverage and use the feedback to craft new inputs for uncovered code. This is good for finding new program states.</li></ul></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2025</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>