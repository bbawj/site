<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Consensus Processes propose values and they all have to agree on one of these values.
 Single Value Consensus  Validity: decided values are those which are proposed Agreement: no 2 correct processes decide differently Termination: every correct process eventually decides Integrity: a process decides at most once   Single Value Uniform Consensus  Uniform Agreement: no 2 processes decide different values Consensus is not solvable in the asynchronous system model if any node is allowed to fail   Unable to detect failure Cannot wait for the correct majority of processes Termination not satisfied: cannot decide  Paxos Algorithm An Eventual Leader Election (weakest leader elector we can use) can be used to eventually elect 1 single proposer (providing termination)."><title>Consensus</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script>
<script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.f42c7fcb66d9399c0737437c54fd65de.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.291bac1df7c56517fe90704c41ede862.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Consensus</h1><p class=meta>Last updated
Feb 16, 2023
<a href=https://github.com/bbawj/site/Notes/Consensus.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#paxos-algorithm>Paxos Algorithm</a><ol><li><a href=#abortable-consensus>Abortable Consensus</a></li></ol></li><li><a href=#multi-paxos>Multi Paxos</a></li><li><a href=#sequence-consensus>Sequence Consensus</a><ol><li><a href=#log-synchronisation>Log Synchronisation</a></li><li><a href=#partial-connectivity-enabling-quorum-connectedness>Partial Connectivity (enabling quorum connectedness)</a></li><li><a href=#failure-recovery>Failure recovery</a></li><li><a href=#reconfiguration>Reconfiguration</a></li></ol></li><li><a href=#raft>Raft</a><ol><li><a href=#state-of-servers>State of servers</a></li><li><a href=#log-reconciliation>Log Reconciliation</a></li></ol></li></ol></nav></details></aside><a href=#consensus><h1 id=consensus><span class=hanchor arialabel=Anchor># </span>Consensus</h1></a><p>Processes propose values and they all have to agree on one of these values.</p><ul><li>Single Value Consensus<ul><li>Validity: decided values are those which are proposed</li><li>Agreement: no 2 <em>correct</em> processes decide differently</li><li>Termination: every correct process eventually decides</li><li>Integrity: a process decides at most once</li></ul></li><li>Single Value Uniform Consensus<ul><li><strong>Uniform</strong> Agreement: no <em>2 processes</em> decide different values
<strong>Consensus is not solvable in the asynchronous system model if any node is allowed to fail</strong></li></ul></li><li>Unable to detect failure</li><li>Cannot wait for the correct majority of processes</li><li>Termination not satisfied: cannot decide</li></ul><a href=#paxos-algorithm><h2 id=paxos-algorithm><span class=hanchor arialabel=Anchor># </span>Paxos Algorithm</h2></a><p>An
<a href=/Notes/Failure-Detectors/ rel=noopener class=internal-link data-src=/Notes/Failure-Detectors/>Eventual Leader Election</a> (weakest leader elector we can use) can be used to eventually elect 1 single proposer <em>(providing termination)</em>.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216162304.png width=auto alt></p><ul><li>Proposers: attempt to impose their proposal to acceptors</li><li>Acceptors: may accept values issued by proposers (cannot talk to each other)</li><li>Learners: decide depending on what is accepted
Contention problem: several processes might initially be proposers</li></ul><a href=#abortable-consensus><h3 id=abortable-consensus><span class=hanchor arialabel=Anchor># </span>Abortable Consensus</h3></a><p>Algorithm aborts if there is contention of multiple proposers.</p><a href=#version-1-centralised><h4 id=version-1-centralised><span class=hanchor arialabel=Anchor># </span>Version 1 (Centralised)</h4></a><p>Proposer sends value to a central acceptor. Acceptor decides on the first value which it gets.
Problem 1: if this acceptor fails, we will never know of the decision</p><a href=#version-2-decentralised><h4 id=version-2-decentralised><span class=hanchor arialabel=Anchor># </span>Version 2 (Decentralised)</h4></a><p>Proposers talk to a set of acceptors, use a majority
<a href=/Notes/Distributed-Abstractions/ rel=noopener class=internal-link data-src=/Notes/Distributed-Abstractions/>quorum</a> to choose a value and enable fault tolerance.
Problem 2: acceptor accepts the first proposal, if messages arrive out of order, possible to have no majority
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216145932.png width=auto alt></p><a href=#version-3-enable-restarts><h4 id=version-3-enable-restarts><span class=hanchor arialabel=Anchor># </span>Version 3 (Enable restarts)</h4></a><p>If no majority value, we need to restart until there is one.
Since proposers can propose again, we need a way to differentiate between them.</p><ul><li>Use a ballot number: sequence number in the form $i, n+i, 2n+i$ for a process $i$ and $n$ processes
Problem 3: restarts lead to different majority accepted values across time, learners cannot make a single decision
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216150901.png width=auto alt></li></ul><a href=#version-4-prepare-and-accept><h4 id=version-4-prepare-and-accept><span class=hanchor arialabel=Anchor># </span>Version 4 (Prepare and Accept)</h4></a><p>We need a way to ensure that every higher number proposal results in the same chosen value</p><ul><li>Satisfied by ensuring acceptors only accept this value</li><li>Satisfied by ensuring proposers only propose this value</li><li>Proposers need to learn this value from the highest sequence number of those accepted. Proposers need to ensure that this &ldquo;highest value&rdquo; does not change.
Proposers query acceptors so that if a value is accepted, every higher proposal issued has the same value previously accepted</li></ul><ol><li>Proposer $prepare(n)$:<ul><li>Gets a promise from acceptors not to accept a proposal with lower ballot number n</li><li>Acceptor also responds with the value corresponding to the highest ballot number proposal</li></ul></li><li>Proposer $accept(n,v)$:<ul><li>Pick the value from the maximum proposal number returned. If none of the processes return a value, proposer can pick freely.</li><li>Acceptor $accept(n,v)$ if not accepted any $prepare(m)$ such that $m>n$; else $reject$</li></ul></li><li>Proposer $decide(v)$ if majority acks; else $abort$
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216162327.png width=auto alt></li></ol><a href=#optimisations><h4 id=optimisations><span class=hanchor arialabel=Anchor># </span>Optimisations</h4></a><ul><li>Reject <code>prepare(n)</code> if accepted <code>prepare(m); m > n</code>: Reject a lower prepare</li><li>Reject <code>accept(n,v)</code> if answered <code>accept(m,u); m > n</code>: Reject a lower accept</li><li>Reject <code>prepare(n)</code> if answered <code>accept(m,u); m > n</code> : Reject a lower accept</li><li>Ignore messages if majority obtained</li></ul><a href=#multi-paxos><h2 id=multi-paxos><span class=hanchor arialabel=Anchor># </span>Multi Paxos</h2></a><p>The motivation: replicated state machines need to agree on a sequence of commands to execute.</p><p>Approach: organise the algorithm into rounds. In each round, each server starts a new instance of Paxos. They propose (2 RTT), accept (2 RTT) and decide on 1 command, add that to the log and restart.</p><p>Initial states</p><ul><li>$ProCmds = \emptyset$: stores the list of commands proposed</li><li>Log = &lt;>: a log of decided commands
A process which wants to execute a command C triggers $rb-broadcast&lt;C, Pid>$. On delivery, the command pair is added to <code>ProCmds</code> unless it is already in Log.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216175839.png width=auto alt>
Problem: the same command across multiple processes might be decided in different slots in time.</li></ul><a href=#sequence-consensus><h2 id=sequence-consensus><span class=hanchor arialabel=Anchor># </span>Sequence Consensus</h2></a><p>Rather than agreeing on a single command and storing that in a Log, we can directly try to agree on the sequence of commands.</p><ul><li>Validity: if process p decides on a value, the value is a sequence of commands</li><li>Uniform Agreement: if process p decides u and another decides v, then <em>one is a prefix of the other</em></li><li>Integrity: process can later decide another value, but the <em>previous value is a strict prefix of the newly decided value</em></li><li>Termination
After adopting a value with highest proposal number, the proposer is allowed to extend the sequence with the new command.
<img src=https://www.brendanang.dev//Pics/Pasted%20image%2020230216180512.png width=auto alt>
Problem: in the prepare phase, processes send a lot of redundant state as the full log is transferred between the proposer and acceptor leading to high IO. No pipelining as well since each round must begin with the prepare phase.</li></ul><a href=#log-synchronisation><h3 id=log-synchronisation><span class=hanchor arialabel=Anchor># </span>Log Synchronisation</h3></a><p>Modify the prepare phase and shared states such that we can work on a single synchronised log $v_a$. <em>To do this, let 1 process act as the sole leader (proposer) until it is aborted by an election of higher ballot number</em>
<img src=https://i.imgur.com/XYiZEZQ.png width=auto alt></p><a href=#prepare-phase><h4 id=prepare-phase><span class=hanchor arialabel=Anchor># </span>Prepare Phase</h4></a><p>The leader sends <code>Prepare</code>:</p><ul><li>current round: $n$</li><li>accepted round: $n_a$</li><li>log length: $|v_a|$</li><li>decided index $l_d$, where the decided sequence is $prefix(v_a,l_d)$
The followers reply with <code>Promise</code>:</li><li>their accepted round</li><li>the log entries which the leader is missing and the leader appends those to the log. <code>AcceptSync</code> is used to synchronise the new log.
<em>Promised followers and leader now have the same common log prefix</em></li></ul><a href=#accept-phase><h4 id=accept-phase><span class=hanchor arialabel=Anchor># </span>Accept Phase</h4></a><p>The leader sends <code>Accept</code> command with highest $n$ to all promised followers
The followers reply with <code>Accepted</code>
When majority accepted, <code>Decide</code> is sent.
Any late <code>Promise</code> is replied with an <code>AcceptSync</code>
<img src=https://i.imgur.com/KZp1A8L.png width=auto alt></p><a href=#partial-connectivity-enabling-quorum-connectedness><h3 id=partial-connectivity-enabling-quorum-connectedness><span class=hanchor arialabel=Anchor># </span>Partial Connectivity (enabling quorum connectedness)</h3></a><p>Chained scenario:
<img src=https://i.imgur.com/543TQYs.png width=auto alt>
When one server loses connectivity to the leader, it will try to elect itself as a leader. Livelock situation as servers compete to become the leader. Can be solved if A becomes the leader but can&rsquo;t because it is already connected to a leader.
Quorum Loss:
<img src=https://i.imgur.com/2Ndk23L.png width=auto alt>
When the leader loses quorum connectivity, deadlock situation as a majority cannot be obtained to make progress. B, D, E cannot elect a leader without a quorum. A is quorum connected but cannot elect a new leader since it is still connected to the alive leader C.
Constrained Election:
<img src=https://i.imgur.com/XHNIYM4.png width=auto alt>
Leader is fully disconnected. A can become the new leader but will not be elected as it does not have the most updated log (log length).
<img src=https://i.imgur.com/9H1UwI5.png width=auto alt></p><p><img src=https://i.imgur.com/HVSEhzS.png width=auto alt></p><a href=#failure-recovery><h3 id=failure-recovery><span class=hanchor arialabel=Anchor># </span>Failure recovery</h3></a><ol><li>Recover state from persistent storage</li><li>Send a <code>PrepareReq</code> to all peers<ul><li>If elected as leader, synchronise through a <code>Prepare</code> phase</li><li><code>Prepare</code> phase from another leader will synchronise</li></ul></li></ol><a href=#reconfiguration><h3 id=reconfiguration><span class=hanchor arialabel=Anchor># </span>Reconfiguration</h3></a><p>Supporting a way to add/replace any process part of the replicated state machine.
A configuration $c_i$ is defined by a set of process ids ${p1, p2, p3}$ and the new configuration can be any new set of processes e.g. ${p1,p2,p4}$</p><a href=#stop-sign><h4 id=stop-sign><span class=hanchor arialabel=Anchor># </span>Stop Sign</h4></a><p>To safely stop the current configuration, we must prevent new decisions in the old configuration (&ldquo;split-brain&rdquo; problem) using a stop sign:
<img src=https://i.imgur.com/lioeEPr.png width=auto alt>
The stop sign contains information about the new configuration to help processes reconfigure:</p><ul><li>the new set of processes in $c_{i+1}$</li><li>the new configuration id number</li><li>the identifiers for each replica in the new configuration
Each process on viewing the stop sign, can safely shut down and restart in the new configuration
A new process not previously part of $c_i$ must perform log migration to catch up with the new instance. Log migration can be done with snapshots of the latest state.</li></ul><a href=#raft><h2 id=raft><span class=hanchor arialabel=Anchor># </span>Raft</h2></a><p>A state of the art consensus algorithm.</p><a href=#state-of-servers><h3 id=state-of-servers><span class=hanchor arialabel=Anchor># </span>State of servers</h3></a><p>Rather than using process ids to break ties for leader election in omnipaxos, Raft uses a form of random retrying when there are split votes.
<img src=https://i.imgur.com/fOSRjUA.png width=auto alt></p><a href=#log-reconciliation><h3 id=log-reconciliation><span class=hanchor arialabel=Anchor># </span>Log Reconciliation</h3></a><p>A server must have the most up to date log in order to become a leader, compared to omni-paxos where any server can be the leader and be synced up during the Prepare phase.
<img src=https://i.imgur.com/EZze9VD.png width=auto alt></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>