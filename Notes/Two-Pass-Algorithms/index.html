<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Two Pass Algorithms The entirety of your data might not always fit in main memory. Two pass algorithms are a class of algorithms used to break down data into chunks which fit into main memory where we can then apply operations."><title>Two Pass Algorithms</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script>
<script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.e8a6b127d86bb72b451f121d293842bb.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.fcb70e4d8f95af4ab555a52704e7b6e4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Two Pass Algorithms</h1><p class=meta>Last updated
Nov 8, 2022
<a href=https://github.com/bbawj/site/Notes/Two%20Pass%20Algorithms.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#sort-based-algorithms>Sort Based Algorithms</a><ol><li><a href=#external-merge-sort>External Merge Sort</a></li><li><a href=#two-phase-multiway-merge-sort>Two-Phase Multiway Merge Sort</a></li><li><a href=#sort-merge-join>Sort-Merge Join</a></li><li><a href=#refined-sort-merge-join>Refined Sort-Merge Join</a></li></ol></li><li><a href=#hash-based-algorithms>Hash Based Algorithms</a><ol><li><a href=#grace-hash-join>Grace Hash Join</a></li><li><a href=#hybrid-hash-join>Hybrid Hash Join</a></li></ol></li><li><a href=#comparison-between-hash--sort-based-join>Comparison between Hash & Sort based Join</a></li><li><a href=#practice-problems>Practice Problems</a></li></ol></nav></details></aside><a href=#two-pass-algorithms><h1 id=two-pass-algorithms><span class=hanchor arialabel=Anchor># </span>Two Pass Algorithms</h1></a><p>The entirety of your data might not always fit in main memory. Two pass algorithms are a class of algorithms used to break down data into chunks which fit into main memory where we can then apply operations.</p><a href=#sort-based-algorithms><h2 id=sort-based-algorithms><span class=hanchor arialabel=Anchor># </span>Sort Based Algorithms</h2></a><p>If data fits in memory, then we can use a standard sorting algorithm like quick-sort. If data does not fit in memory, then we need to use a technique that is aware of the cost of writing data out to disk.</p><a href=#external-merge-sort><h3 id=external-merge-sort><span class=hanchor arialabel=Anchor># </span>External Merge Sort</h3></a><p>Idea is similar to
<a href=/Notes/Merge-Sort/ rel=noopener class=internal-link data-src=/Notes/Merge-Sort/>Merge Sort</a>. By breaking the data into pairs, we can sort each pair and merge them recursively.
We have 2 buffers for READ and 1 buffer for write: B(R) = 4
<img src=https://i.imgur.com/iWVMUnT.png width=auto alt>
Since each run may not fully fit inside memory, we can load segments of pairs of runs (e.g. 1 block from each run even though run contains 2 blocks), merge them and immediately write them back to the disk.</p><a href=#two-phase-multiway-merge-sort><h3 id=two-phase-multiway-merge-sort><span class=hanchor arialabel=Anchor># </span>Two-Phase Multiway Merge Sort</h3></a><p>We do not fully utilise all the buffers in external merge sort if M > 3.
Idea:</p><ol><li>Divide data into $\frac{B}{M}$ sublists each of size $M$.</li><li>Sort each chunk and write it back to the disk</li><li>Use 1 input buffer for each sorted sublist. Implication: <em>hence there can only be M-1 sublists</em><ol><li>Take the smallest of the head of each sublist (each in 1 buffer) and move into output</li><li>If a buffer is empty: load tuples into the block from the same sorted sublist</li><li>If no blocks remain in the sublist, ignore</li></ol></li></ol><blockquote class="[! note]-callout"><p>[! Note]
Suppose R fits on B blocks. With M buffers each of 1 block, we can effectively sort M blocks of data each time. We can form $B(R)/M$ sorted sublists. In total we will only read and write B(R) blocks for this step.</p><p>Since we need 1 input buffer to represent each head of a sublist, we will need $B(R)/M \le(M-1), \\ or\\ B(R)\le M\times (M-1)\approx M^2$</p><p>E.g. Suppose blocks are 64K bytes, and we have one gigabyte of main memory. Then we can afford M of 16K. Thus, a relation fitting in B blocks can be sorted as long as B is no more than $(16K)^2 = 2^{28}$. Since blocks are of size $64K = 2^{14}$, a relation can be sorted as long as its size is no greater than $2^{42}$ bytes, or 4 terabytes.</p></blockquote><p>If B(R) cannot be split into sublists of size M $i.e. B(R)/M \ge M$, first split B(R) into sublists of size $M(M-1)$. Apply 2PMMS to each of these $\frac{B(R)}{M(M-1)}$ chunks to get M sorted sublists. This forms the input for a third pass to form a fully sorted relation.</p><a href=#cost><h4 id=cost><span class=hanchor arialabel=Anchor># </span>Cost</h4></a><p>Let B be the number of blocks. B disk I/O to read in the first pass. B disk I/O to write sorted sublists. B disk I/O to read sorted sublists in second pass. <strong>Total 3B disk I/O</strong>.</p><a href=#sort-merge-join><h3 id=sort-merge-join><span class=hanchor arialabel=Anchor># </span>Sort-Merge Join</h3></a><p>Idea: If the tuples are sorted, we can more easily join them together
Algorithm:</p><ol><li>Sort R and S according to a key Y using 2PMMS</li><li>Merge R and S using only 2 buffers, one for the current block of R and another for the current block of S.<ol><li>Find the least value of y that is currently at front of blocks R and S</li><li>If y does not appear at the front of the other relation, remove the tuples with value y</li><li>Else, find tuples from both relations having sort key y, If necessary, read blocks from R and S until we are sure that there are no more y&rsquo;s in either relation. **We can use up to M buffers for this purpose</li><li>Output all the tuples that can be formed by joining these tuples</li><li>If either relation has no more unconsidered tuples in main memory, reload the buffer for that relation
<img src=https://i.imgur.com/n35JBo0.png width=auto alt></li></ol></li></ol><a href=#implications><h4 id=implications><span class=hanchor arialabel=Anchor># </span>Implications</h4></a><p>Tuples with a common value of the sort key from both relations together must fit in M blocks. Consider if there are more than M such tuples. We will not be able to load the needed tuples for joining in 1 pass.</p><a href=#cost-1><h4 id=cost-1><span class=hanchor arialabel=Anchor># </span>Cost</h4></a><p>3B disk I/O per relation in step 1 for sorting, 1B per relation additionally to write fully sorted back to disk
1B disk I/O per relation in step 2
Total: $5(B(R) + B(S))$ disk I/O</p><a href=#refined-sort-merge-join><h3 id=refined-sort-merge-join><span class=hanchor arialabel=Anchor># </span>Refined Sort-Merge Join</h3></a><p>Notice that in sort-merge join, the 2 relations are sorted first and then merged in distinct passes creating the greatest possible numbers of buffers available for joining tuples with common value.</p><p>If we do not need to worry about large number of tuples sharing common sort key, we can join the tuples in the merge phase of the sort:</p><ol><li>Created M sorted sublists using sort key Y</li><li>Bring the first block of each sublist into a buffer</li><li>Repeatedly find the smallest y value. Find tuples of both relations that have value y.</li></ol><a href=#cost-2><h4 id=cost-2><span class=hanchor arialabel=Anchor># </span>Cost</h4></a><p>Step 1 will require 2 I/O per block in order to read, form the sorted sublists and write back to disk
Step 2 will require 1 I/O per block in order to read and merge
Total: $3(B(R) + B(S))$ disk I/O</p><a href=#implications-1><h4 id=implications-1><span class=hanchor arialabel=Anchor># </span>Implications</h4></a><p>We need all sorted sublists from both relations to be able to fit in memory.
Number of sorted sublists = $(B_R+B_S)/M$
$(B_R+B_S)/M \le M$
$(B_R+B_S) \le M^2$
<img src=https://i.imgur.com/pbW2M5z.png width=auto alt></p><a href=#hash-based-algorithms><h2 id=hash-based-algorithms><span class=hanchor arialabel=Anchor># </span>Hash Based Algorithms</h2></a><p>Idea: hash the data into M buckets in order to fit into M main memory buffers for operations.
<img src=https://i.imgur.com/S5ERzLt.png width=auto alt></p><a href=#grace-hash-join><h3 id=grace-hash-join><span class=hanchor arialabel=Anchor># </span>Grace Hash Join</h3></a><ol><li>Hash both relations to M-1 buckets using join key</li><li>Join every pair of matching hash key buckets in 1 pass<ol><li>Load all the buckets of one relation into M - 1 buffers</li><li>One by one, load buckets from the other relation and join</li></ol></li></ol><a href=#implications-2><h4 id=implications-2><span class=hanchor arialabel=Anchor># </span>Implications</h4></a><p>The relation which smaller number of buckets must at least fit into M - 1 buffers.
$min(\frac{B(R)}{M-1}, \frac{B(S)}{M-1}) \le M-1 \approx min(B(R),B(S))\le M^2$</p><a href=#cost-3><h4 id=cost-3><span class=hanchor arialabel=Anchor># </span>Cost</h4></a><p>Step 1: 2 disk I/O per block to hash and write back to disk
Step 2: 1 disk I/O per block as we read 1 block once only before joining
Total: $3(B(R) + B(S))$ disk I/O</p><a href=#hybrid-hash-join><h3 id=hybrid-hash-join><span class=hanchor arialabel=Anchor># </span>Hybrid Hash Join</h3></a><p>What if the size of one of our relations is much smaller than the M? $B(S) &#171; M^2$
We can leave some buckets of S in memory without writing to disk such that we can join with B(R) immediately.</p><ol><li>Partition S into k buckets, keep $t$ buckets in memory and $k-t$ buckets in the disk</li><li>Partition R into k buckets, first $t$ buckets are joined with S</li><li>Join $k-t$ pairs of buckets</li></ol><a href=#implications-3><h4 id=implications-3><span class=hanchor arialabel=Anchor># </span>Implications</h4></a><p>The $t$ hash buckets saved in memory + the blocks for each head of each hash bucket written to disk must fit entirely in memory.
$$t\times\frac{B(R)}{k}+k-t\le M$$</p><a href=#cost-4><h4 id=cost-4><span class=hanchor arialabel=Anchor># </span>Cost</h4></a><p>Average bucket size is $B(S)/k$. We save write and read of $t\times B/k$ blocks for each relation
Total cost: $3(B(R) + B(S)) - \frac{2\times t}{k}(B(R)+B(S))$</p><a href=#comparison-between-hash--sort-based-join><h2 id=comparison-between-hash--sort-based-join><span class=hanchor arialabel=Anchor># </span>Comparison between Hash & Sort based Join</h2></a><p><img src=https://i.imgur.com/oxbKLxs.png width=auto alt></p><a href=#practice-problems><h2 id=practice-problems><span class=hanchor arialabel=Anchor># </span>Practice Problems</h2></a><p><img src=https://i.imgur.com/zirdVdQ.png width=auto alt>
We can eliminate duplicates through sorting.</p><ol><li>Divide data into M-1 buffers</li><li>Sort each buffer and write it back to the disk.</li><li>2nd pass: read all the sorted sublists into M-1 buffers</li><li>Move the smallest of the heads of each sublist into the output if the max of the current output does not already contain this incoming value.
<img src=https://i.imgur.com/aFtQUQT.png width=auto alt>
a. M = 3. Sort merge join of S and T. Sort merge join of R and the result of S and T. 1 block to read R, 1 block to read S, 1 block to hold intermediate result of $R\Join S$
<img src=https://i.imgur.com/OzmoV03.png width=auto alt>
b.
II: $M > B_T$
III: $M > B_T+(\text{Number of sorted sublists of S})+1$. Need all sorted sublists in buffer, and need 1 additional buffer to comb through R
<img src=https://i.imgur.com/R8RCdvQ.png width=auto alt>
<del>Yes. Only refined sort merge join has comparable cost. In this case, refined sort merge join will not be applicable as both relations share multiple common values of attribute Y. Hence we are not able to fully load all tuples with the same attribute value into M buffers.</del>
No. Hash join works by partitioning the relations based on the distinct keys. Since there are very few distinct values of Y, there will be very little partitions. 2nd pass will not work well since each partition must be loaded fully into memory buffer.
<img src=https://i.imgur.com/8v4AFJU.png width=auto alt>
a.
Strategy:</li><li>Use R as the outer relation as it is smaller.</li><li>Keep 1 hash bucket in memory. Need to be able to load all hash buckets from one of the relations into the remaining memory.
$$\begin{aligned}
\\text{Let k be the number of hash buckets}
\\text{No. of buffers for S}=1
\\text{No. of buffers to write k-1 buckets to disk}=k-1
\\text{No. of buffers to keep 1 bucket on memory}=B(R)/k
\M\ge 1+k-1+B(R)/k=k+B(R)/k
\end{aligned}
$$
<img src=https://i.imgur.com/Z5Xc1G6.png width=auto alt>
b.
We save the cost of writing and reading 1 bucket of R to/from disk during the hashing process.
Each bucket contains $(400)/20=20blocks$
Total cost: $3(B_R+B_S)-2\times20=2660$
<img src=https://i.imgur.com/VRlK61d.png width=auto alt>
i. Set union operation involves duplicate elimination. Disk I/O = $B(R)+ B(R)\times B(S)=100010000$
ii.
For refined sort merge join:</li><li>Read all blocks to perform 2PMMS: $2(B_R + B_S)=40000$</li><li>Perform join on merge phase: $1(B_R + B_S)=20000$
Total = 60000 i/o
<img src=https://i.imgur.com/hSue1Sr.png width=auto alt>
i. The minimum number of main memory blocks needed is that the relation with smaller number of hashed blocks must fit entirely into the main memory. Assuming that each block hashes to its own hash bucket, we need $M=10000$
<img src=https://i.imgur.com/HT6UlMm.png width=auto alt>
i. $3\times (B_R + B_S) =4500$
ii. $3\times (B_R + B_S) =4500$
<img src=https://i.imgur.com/4kcfjW9.png width=auto alt>
Procedure:</li><li>Sort R and S according to the attribute $x$ using two phase multiway merge sort</li><li>Load the first block of sorted R and S into main memory</li><li>Find tuple with the smallest value of $x$ and find matching tuples and write them to the output buffer</li><li>Repeatedly find the smallest value of $x$ once all tuples with the current smallest value are considered</li><li>Reload new blocks when either relation&rsquo;s blocks are fully considered
Cost:
$B_R=30000/30=1000$
$B_S=9000/10=900$
Sorting: $3(B_R+B_S)=5700$
Joining: $2(B_R+B_S)=3800$
Total: 9500
<img src=https://i.imgur.com/u0VLkYZ.png width=auto alt>
<img src=https://i.imgur.com/vib08yl.png width=auto alt>
i.
$B_R=50$
$(B_R+B_S)/10 \le10$
$50+\frac{2000}{x}\le100$
$x\ge40$
ii.
$3(B_R+B_S)=3(50+50)=300$
iii.
Use 9 buffers for one relation.
$B_R+B_R\times B_S/9=328$
iv.
$3(B_R+B_S)=3(50+50)=300$
v.
Choose between refined sort merge join and grace hash join as they have the smallest I/O cost. Choose refined sort merge join because the output will also be sorted.</li></ol></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/4031-Database-Systems/ data-ctx="Two Pass Algorithms" data-src=/4031-Database-Systems class=internal-link>4031 Database Systems</a></li><li><a href=/Notes/Index-Based-Algorithms/ data-ctx data-src=/Notes/Index-Based-Algorithms class=internal-link>Index Based Algorithms</a></li><li><a href=/Notes/Query-Optimisation/ data-ctx data-src=/Notes/Query-Optimisation class=internal-link>Query Optimisation</a></li><li><a href=/Notes/Query-Processing/ data-ctx="Two Pass Algorithms" data-src=/Notes/Query-Processing class=internal-link>Query Processing</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>