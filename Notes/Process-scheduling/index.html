<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Process Scheduling A process execution alternates between CPU executions and I/O operations CPU Burst: duration of one CPU execution cycle I/O Burst: duration of one I/O operation (wait time) Types All processes are stored in queue structures Job queue: set of all processes with the same state in the system"><title>Process scheduling</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script>
<script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.f42c7fcb66d9399c0737437c54fd65de.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.291bac1df7c56517fe90704c41ede862.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Process scheduling</h1><p class=meta>Last updated
Nov 8, 2022
<a href=https://github.com/bbawj/site/Notes/Process%20scheduling.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#types>Types</a></li><li><a href=#objectives>Objectives</a></li><li><a href=#uni-core-algorithms>Uni-Core Algorithms</a><ol><li><a href=#first-come-first-serve-fcfs>First Come First Serve (FCFS)</a></li><li><a href=#shortest-job-first-sjf>Shortest Job First (SJF)</a></li><li><a href=#priority-based>Priority Based</a></li><li><a href=#round-robin>Round Robin</a></li><li><a href=#multi-queue>Multi-Queue</a></li></ol></li><li><a href=#multi-core-algorithms>Multi-Core Algorithms</a><ol><li><a href=#partitioned-scheduling>Partitioned Scheduling</a></li><li><a href=#global-scheduling>Global Scheduling</a></li></ol></li><li><a href=#practice-problems>Practice Problems</a></li></ol></nav></details></aside><a href=#process-scheduling><h1 id=process-scheduling><span class=hanchor arialabel=Anchor># </span>Process Scheduling</h1></a><p>A process execution alternates between CPU executions and I/O operations
<strong>CPU Burst</strong>: duration of one CPU execution cycle
<strong>I/O Burst</strong>: duration of one I/O operation (wait time)
<img src=https://i.imgur.com/dztmS0B.png width=auto alt></p><a href=#types><h2 id=types><span class=hanchor arialabel=Anchor># </span>Types</h2></a><p>All processes are stored in queue structures
Job queue: set of all processes with the same state in the system</p><ul><li>ready queue: processes in the ready state</li><li>device queue: processes waiting for specific I/O device</li></ul><p>A scheduler will be in charge of handling these queues
<img src=https://i.imgur.com/fjJLGsE.png width=auto alt></p><p><img src=https://i.imgur.com/JWypMYa.png width=auto alt></p><a href=#objectives><h2 id=objectives><span class=hanchor arialabel=Anchor># </span>Objectives</h2></a><p><strong>System</strong>:</p><ol><li>Maximize CPU utilization<ul><li>Increase the % of time which CPU cores are busy executing processes</li><li>$\frac{\text{Total execution time}}{\text{Total time}}$</li></ul></li><li>Maximize throughput<ul><li>Number of processes that complete their execution per unit time (number of exit transitions)
<strong>Process</strong>:</li></ul></li><li>Minimize turnaround time<ul><li>Amount of time to finish executing a particular process (e.g. time between admitted and exit transitions)</li></ul></li><li>Minimize waiting time<ul><li>Amount of time process is in the <strong>ready</strong> state</li><li>__Turnaround time - CPU burst time</li></ul></li><li>Minimize response time<ul><li>Time between admission and first response (assume to be start of execution)</li></ul></li></ol><a href=#uni-core-algorithms><h2 id=uni-core-algorithms><span class=hanchor arialabel=Anchor># </span>Uni-Core Algorithms</h2></a><a href=#first-come-first-serve-fcfs><h3 id=first-come-first-serve-fcfs><span class=hanchor arialabel=Anchor># </span>First Come First Serve (FCFS)</h3></a><p>Non pre-emptive type: processes have to voluntarily release CPU once allocated
<img src=https://i.imgur.com/Zl2BurR.png width=auto alt></p><p><strong>Convoy effect:</strong> Short processes suffer increased waiting times due to earlier arrived long processes
<img src=https://i.imgur.com/mNeQ2yS.png width=auto alt></p><a href=#shortest-job-first-sjf><h3 id=shortest-job-first-sjf><span class=hanchor arialabel=Anchor># </span>Shortest Job First (SJF)</h3></a><p>How to handle the convoy effect from FCFS? <strong>Prioritize processes based on CPU burst lengths</strong></p><p><strong>Non pre-emptive</strong>: a process cannot be stopped. Preemption only after a process is completed
<strong>Pre-emptive</strong> (Shortest Remaining Time First): processes in the midst of execution can be rescheduled
<img src=https://i.imgur.com/aNa162L.png width=auto alt>
This algorithm is optimal to achieve minimum average waiting time. <em>However, this algorithm is often not used in practice as it is difficult to know the burst length of a process.</em></p><a href=#priority-based><h3 id=priority-based><span class=hanchor arialabel=Anchor># </span>Priority Based</h3></a><p>CPU is allocated to the process with highest priority</p><ol><li>Priority based on arrival order (FCFS)</li><li>Priority base on CPU burst length (SJF)</li></ol><p>Starvation problem: lower priority processes may never execute. Need to use aging to slowly increase priority of processes that have been in the pipeline longer.</p><a href=#round-robin><h3 id=round-robin><span class=hanchor arialabel=Anchor># </span>Round Robin</h3></a><p>Use a fixed time quantum (q) for scheduling. A process is allocated CPU for q time units and after that it is preempted and inserted at the end of the ready queue.</p><p>Large q: degenerates to FCFS
Small q: many context switches leading to greater overhead
<img src=https://i.imgur.com/EIaetjn.png width=auto alt>
<em>This is the algorithm that is used most commonly in practice</em>
<img src=https://i.imgur.com/wKh7X6w.png width=auto alt></p><a href=#multi-queue><h3 id=multi-queue><span class=hanchor arialabel=Anchor># </span>Multi-Queue</h3></a><p><img src=https://i.imgur.com/REMdkaK.png width=auto alt></p><p><img src=https://i.imgur.com/dMrin7M.png width=auto alt></p><a href=#multi-core-algorithms><h2 id=multi-core-algorithms><span class=hanchor arialabel=Anchor># </span>Multi-Core Algorithms</h2></a><a href=#partitioned-scheduling><h3 id=partitioned-scheduling><span class=hanchor arialabel=Anchor># </span>Partitioned Scheduling</h3></a><p>Each process are partitioned at process creation time among CPU cores
Each process is mapped to one core
<strong>Asymmetric scheduling</strong>: each CPU can have a separate scheduling strategy/algorithm</p><p>How to map cores to processes?</p><ul><li>Burst lengths are not easy to know</li><li>For a CPU capacity, we need to maximize a certain property: similar to
<a href=/Notes/Knapsack-Problem/ rel=noopener class=internal-link data-src=/Notes/Knapsack-Problem/>Knapsack Problem</a></li><li>Thus, partitioned scheduling suffers from unbalanced loading of cores</li></ul><a href=#global-scheduling><h3 id=global-scheduling><span class=hanchor arialabel=Anchor># </span>Global Scheduling</h3></a><p>Maintain 1 or more ready queues for the entire system without mapping any queue to any CPU core
<strong>Symmetric scheduling</strong>: one scheduling strategy/algorithm across all cores
<img src=https://i.imgur.com/iIndE5i.png width=auto alt></p><p><img src=https://i.imgur.com/CLAO4wv.png width=auto alt></p><p><img src=https://i.imgur.com/a7HDMCi.png width=auto alt></p><a href=#practice-problems><h2 id=practice-problems><span class=hanchor arialabel=Anchor># </span>Practice Problems</h2></a><p>Under Round-Robin scheduling, if quantum size is q, average CPU burst length is B, average number of CPU bursts per process is N, and average number of processes in the ready queue is R, then the average response time for a process is?
$$\frac{0+q+2q+3q+&mldr;+(R-1)q}{R} = \frac{\frac{R}{2}(R-1)q}{R}=(R-1)q$$
<img src=https://i.imgur.com/KuJF3Ze.png width=auto alt>
a. False. If the CPU cannot be removed from the process, it is non-preemptive
b. False. Only need to run scheduler when a process exits or changes to waiting
c. False. Response time is time to first start of execution. Turnaround time is time to finish the process. Waiting time is time in the ready state. Turnaround - waiting time is just the time in the waiting and running states combined.
d. False. Migration overheads occur in global scheduling when a process partially executes on one core and then migrates to another. In partitioned scheduling processes donâ€™t migrate between cores. However, partitioned scheduling has the problem of unbalanced loading of the cores depending on the process-core mapping.
<img src=https://i.imgur.com/w1gOgdk.png width=auto alt>
abc.
<img src=https://www.brendanang.dev//Excalidraw/Drawing%202022-08-28%2021.06.51.excalidraw.svg width=auto alt=800>
d.
Uni-core: RR
Duo-core: RR, SRTF
<img src=https://i.imgur.com/SyhdEDn.png width=auto alt>
Efficiency is total process time over total process time + total overhead: $\frac{T}{T+kS}$
where k is the total number of context switches
<em>we should also include the 1st context switch needed to start process</em>
a. If $Q->\infty$, there will be 0 context switches
$Efficiency=\frac{T}{T+S} = 1$
b. If Q >T, average process will run without context switching
$Efficiency=\frac{T}{T+S}= 1$
c. S &lt; Q &lt; T. Average process will switch T/Q times.
$Efficiency=\frac{T}{S\times\lceil\frac{T}{Q}\rceil}$
c. Q = S. Average process will switch T/S times.
$Efficiency=\frac{T}{T+\frac{T}{S}S} = \frac{T}{2T}=0.5$
d. Q -> 0, number of switches tend to infinity
$Efficiency=0$</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/2005-Operating-Systems/ data-ctx="Process scheduling" data-src=/2005-Operating-Systems class=internal-link>2005 Operating Systems</a></li><li><a href=/Notes/Disk/ data-ctx data-src=/Notes/Disk class=internal-link>Disk</a></li><li><a href=/Notes/Processes/ data-ctx="Process scheduling" data-src=/Notes/Processes class=internal-link>Processes</a></li><li><a href=/Notes/Real-Time-Operating-Systems/ data-ctx="Classical scheduling algorithms" data-src=/Notes/Real-Time-Operating-Systems class=internal-link>Real Time Operating Systems</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>