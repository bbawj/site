<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Process Synchronization  Race Condition
Critical Section Problem One method to solve the race condition is to divide processes into critical sections which are segments that shared data is accessed."><title>Process Synchronization</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://www.brendanang.dev//icon.png><link href=https://www.brendanang.dev/styles.c6adaa3b473914a38283f492dfdbcb76.min.css rel=stylesheet><link href=https://www.brendanang.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://www.brendanang.dev/js/darkmode.f4d43c22d05773345705b5a308888af6.min.js></script>
<script src=https://www.brendanang.dev/js/util.fa8e74b4065b97e6980a72cc472e436f.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://www.brendanang.dev/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://www.brendanang.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://www.brendanang.dev/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://www.brendanang.dev/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,PRODUCTION=!0,BASE_URL="https://www.brendanang.dev/",fetchData=Promise.all([fetch("https://www.brendanang.dev/indices/linkIndex.766f6378416d06929f0850ebe8548419.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://www.brendanang.dev/indices/contentIndex.2ef04b81ecf316e06ecb73f191794004.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://www.brendanang.dev",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://www.brendanang.dev",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/www.brendanang.dev\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://www.brendanang.dev/js/full-text-search.51f0b1753e9b30839d053f8a98cc20d1.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://www.brendanang.dev/>Brendan Ang</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Process Synchronization</h1><p class=meta>Last updated
Nov 8, 2022
<a href=https://github.com/bbawj/site/Notes/Process%20Synchronization.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#critical-section-problem>Critical Section Problem</a></li><li><a href=#user-level-solutions>User-level Solutions</a><ol><li><a href=#turn-variable>Turn variable</a></li><li><a href=#flag-variable>Flag variable</a></li><li><a href=#pertersons-solution>Perterson&rsquo;s Solution</a></li></ol></li><li><a href=#hardware-solution>Hardware Solution</a><ol><li><a href=#synchronization-hardware>Synchronization Hardware</a></li></ol></li><li><a href=#operating-system-solution>Operating System Solution</a><ol><li><a href=#mutex-locks>Mutex Locks</a></li><li><a href=#semaphore>Semaphore</a></li></ol></li><li><a href=#common-patterns>Common Patterns</a><ol><li><a href=#signalling>Signalling</a></li></ol></li><li><a href=#classical-problems-of-synchronization>Classical Problems of Synchronization</a><ol><li><a href=#bounded-buffer>Bounded Buffer</a></li><li><a href=#dining-philosophers>Dining Philosophers</a></li><li><a href=#readers-writers>Readers-Writers</a></li></ol></li><li><a href=#practice-problems>Practice Problems</a></li></ol></nav></details></aside><a href=#process-synchronization><h1 id=process-synchronization><span class=hanchor arialabel=Anchor># </span>Process Synchronization</h1></a><p><a href=/Notes/Race-Condition/ rel=noopener class=internal-link data-src=/Notes/Race-Condition/>Race Condition</a></p><a href=#critical-section-problem><h2 id=critical-section-problem><span class=hanchor arialabel=Anchor># </span>Critical Section Problem</h2></a><p>One method to solve the race condition is to divide processes into critical sections which are segments that shared data is accessed. <strong>One process must be writing.</strong></p><p>Problem: design protocol to ensure that no 2 processes are executing their critical section at the same time.</p><p>We need to satisfy 3 properties:</p><ol><li><strong>Mutual exclusion</strong>: if process is executing in critical section, no other process can be executing in its critical section at the same time.
*Why is mutual exclusion not enough?<ul><li>It can be achieved naively by preventing any process from entering critical section</li></ul></li><li><strong>Progress</strong>: if no process is executing in its critical section and another process needs to enter their critical section, selection of this process to enter cannot be postponed indefinitely</li><li><strong>Bounded waiting</strong>: if a process needs to enter their critical section, all other processes are allowed to enter their own critical section only a bounded number of times</li></ol><a href=#user-level-solutions><h2 id=user-level-solutions><span class=hanchor arialabel=Anchor># </span>User-level Solutions</h2></a><p>Following examples show how it is possible for 2 processes. <em>For more processes, it becomes unfeasible</em></p><a href=#turn-variable><h3 id=turn-variable><span class=hanchor arialabel=Anchor># </span>Turn variable</h3></a><p><img src=https://i.imgur.com/K9rspxV.png width=auto alt>
Progress is violated:</p><ol><li>P1 finish critical section and pass the turn over to P0</li><li>P0 finish its critical section and pass the turn over to P1</li><li>P1 runs in a long remainder section and never passes turn back to P0</li><li>Context switch occurs, P0 needs to enter critical section but P1 is stuck running remainder for a long period
<img src=https://i.imgur.com/2jrBrZ2.png width=auto alt></li></ol><a href=#flag-variable><h3 id=flag-variable><span class=hanchor arialabel=Anchor># </span>Flag variable</h3></a><p><img src=https://i.imgur.com/wU8koJx.png width=auto alt></p><p><img src=https://i.imgur.com/YPYh9dL.png width=auto alt></p><a href=#pertersons-solution><h3 id=pertersons-solution><span class=hanchor arialabel=Anchor># </span>Perterson&rsquo;s Solution</h3></a><p><img src=https://i.imgur.com/TaegYbO.png width=auto alt>
Mutual exclusion:</p><ul><li>Pi enters its critical section only if either flag[j] <mark>false or turn</mark> i. Also note that, if both processes can be executing in their critical sections at the same time, then flag[0] <mark>flag[1]</mark> true. These two observations imply that P0 and P1 could not have successfully executed their while statements at about the same time, since the value of turn can be either 0 or 1 but cannot be both. Hence, one of the processes—say, Pj —must have successfully executed the while statement, whereas Pi had to execute at least one additional statement (“turn <mark>j”). However, at that time, flag[j]</mark> true and turn <mark>j, and this condition will persist as long as Pj is in its critical section; as a result, mutual exclusion is preserved.
Progress:</li><li>Pi can be prevented from entering the critical section only if it is stuck in the while loop with the condition flag[j]</mark> true and turn <mark>j</li><li>If Pj is not ready to enter the critical section, then flag[j]</mark> false, and Pi can enter its critical section. If Pj has set flag[j] to true and is also executing in its while statement, then either turn <mark>i or turn</mark> j. If turn <mark>i, then Pi will enter the critical section. If turn</mark> j, then Pj will enter the critical section.
Bounded Waiting:</li><li>When $P_i$ exits its critical section, flag[j] == false and $P_i$ is allowed to enter its critical section. Assume $P_j$ resets flag[j] <mark>true, it will subsequently set turn</mark> i. Since $P_i$ cannot change the turn value while in the loop, it is allowed to enter the critical section after at most 1 entry by $P_j$</li></ul><a href=#hardware-solution><h2 id=hardware-solution><span class=hanchor arialabel=Anchor># </span>Hardware Solution</h2></a><a href=#synchronization-hardware><h3 id=synchronization-hardware><span class=hanchor arialabel=Anchor># </span>Synchronization Hardware</h3></a><p>Race condition is a result of context switches. We can prevent that in hardware to have atomic instructions.
<img src=https://i.imgur.com/gJrBVWr.png width=auto alt>
<em>Difficult to control the disabling of context switches in user level as there may be many critical regions and regions execute for unknown amounts of time</em>
TestAndSet is now an assembly instruction which can be used to acquire a lock:
<img src=https://i.imgur.com/ML23PqH.png width=auto alt></p><ul><li>No context switches can occur while setting the lock value</li><li>This means that whoever runs this instruction first will run first, no other process will be able to enter critical region</li><li>If lock <mark>true, someone is in the critical section: we are blocked</li><li>If lock</mark> false, we set lock to true and move into the critical section
<img src=https://i.imgur.com/zwFGrJq.png width=auto alt>
Hardware has no memory of process trying to access the lock. P0 able to indefinitely take the lock without giving P1 a chance.</li></ul><a href=#operating-system-solution><h2 id=operating-system-solution><span class=hanchor arialabel=Anchor># </span>Operating System Solution</h2></a><a href=#mutex-locks><h3 id=mutex-locks><span class=hanchor arialabel=Anchor># </span>Mutex Locks</h3></a><p><img src=https://i.imgur.com/pLZl78y.png width=auto alt></p><a href=#semaphore><h3 id=semaphore><span class=hanchor arialabel=Anchor># </span>Semaphore</h3></a><p><img src=https://i.imgur.com/NFRVyYv.png width=auto alt></p><ul><li>A binary sempahore behaves similar to mutex locks.</li><li>A counting semaphore is used to control access to a given resource consisting of a finite number of instances. <strong>It is initalised to the number of resources available</strong>.</li></ul><a href=#busy-waiting-solution><h4 id=busy-waiting-solution><span class=hanchor arialabel=Anchor># </span>Busy waiting <em>solution</em></h4></a><p>Also known as a <em>spinlock</em>, where a thread trying to acquire a lock is caused to wait in a loop (&ldquo;spin&rdquo;) while repeatedly checking if the lock is available.
<img src=https://i.imgur.com/aPAwIXL.png width=auto alt>
Atomicity is not possible for this solution on a single-core. If a process P0 must loop to execute <code>Wait(S)</code>, no other processes can execute <code>Signal(S)</code> in order to allow P0 to continue. If we cannot context switch then there is no solution.</p><a href=#blocking-solution><h4 id=blocking-solution><span class=hanchor arialabel=Anchor># </span>Blocking Solution</h4></a><p><img src=https://i.imgur.com/tiVca7I.png width=auto alt></p><p><img src=https://i.imgur.com/IgHj0f5.png width=auto alt></p><ul><li>Process is in the waiting state because the process cannot use the CPU (and following which enter its critical section) if another process is currently in its critical section</li><li>Process woken up is changed to ready state but the CPU may not switch from the currently running process to this newly ready process depending on scheduling
<img src=https://i.imgur.com/Mc1Ihj1.png width=auto alt>
Atomicity needed for these system calls:
<img src=https://i.imgur.com/YRNgQVD.png width=auto alt></li></ul><a href=#common-patterns><h2 id=common-patterns><span class=hanchor arialabel=Anchor># </span>Common Patterns</h2></a><a href=#signalling><h3 id=signalling><span class=hanchor arialabel=Anchor># </span>Signalling</h3></a><p>One thread sends a signal to another thread to indicate something has happened
<img src=https://i.imgur.com/7fHTzV1.png width=auto alt></p><ul><li>Ensure a1 before b2</li><li>Ensure b1 before a2</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>aArrived = Semaphore(0)
</span></span><span class=line><span class=cl>bArrived = Semaphore(0)
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>statement a1</td><td>statement b1</td></tr><tr><td><code>aArrived.signal()</code></td><td><code>bArrived.signal()</code></td></tr><tr><td><code>bArrived.wait()</code></td><td><code>aArrived.wait()</code></td></tr><tr><td>statement a2</td><td>statement b2</td></tr></tbody></table><a href=#classical-problems-of-synchronization><h2 id=classical-problems-of-synchronization><span class=hanchor arialabel=Anchor># </span>Classical Problems of Synchronization</h2></a><a href=#bounded-buffer><h3 id=bounded-buffer><span class=hanchor arialabel=Anchor># </span>Bounded Buffer</h3></a><p><img src=https://i.imgur.com/Y7Jf4tR.png width=auto alt>
<img src=https://i.imgur.com/1R40zE1.png width=auto alt>
The order of access to the shared variables matter. Logically, each process should check if the resource is available (in the case of consumer) OR if there is currently no instances (for producers), before trying to access the buffer through the mutex lock.
Producer:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>do</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// wait until empty &gt; 0 and then decrement &#39;empty&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait</span><span class=p>(</span><span class=nx>empty</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>    <span class=c1>// acquire lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait</span><span class=p>(</span><span class=nx>mutex</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* perform the insert operation in a slot */</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// release lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=nx>mutex</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// increment &#39;full&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=nx>full</span><span class=p>);</span>   
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=nf>while</span><span class=p>(</span><span class=nx>TRUE</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Consumer:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>do</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// wait until full &gt; 0 and then decrement &#39;full&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait</span><span class=p>(</span><span class=nx>full</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// acquire the lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>wait</span><span class=p>(</span><span class=nx>mutex</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* perform the remove operation in a slot */</span> 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// release the lock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=nx>mutex</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// increment &#39;empty&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=nx>empty</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=nf>while</span><span class=p>(</span><span class=nx>TRUE</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#dining-philosophers><h3 id=dining-philosophers><span class=hanchor arialabel=Anchor># </span>Dining Philosophers</h3></a><p><img src=https://i.imgur.com/xeUVrNj.png width=auto alt></p><p><img src=https://i.imgur.com/zTf3nWu.png width=auto alt></p><ul><li>If each process executes the first <code>wait(chopstick)</code> and context switches, every process only has 1 chopstick and is stuck in a deadlock
Solutions:
<img src=https://i.imgur.com/q9Gp6b0.png width=auto alt></li></ul><a href=#readers-writers><h3 id=readers-writers><span class=hanchor arialabel=Anchor># </span>Readers-Writers</h3></a><p><img src=https://i.imgur.com/mobJGtN.png width=auto alt></p><p><img src=https://i.imgur.com/23qQMhV.png width=auto alt>
Writer:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=nx>wrt</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//write
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>signal</span><span class=p>(</span><span class=nx>wrt</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#second-readers-writers-problem><h4 id=second-readers-writers-problem><span class=hanchor arialabel=Anchor># </span>Second Readers-Writers Problem</h4></a><p>It is possible that a reader <em>R1</em> might have the lock, a writer <em>W</em> be waiting for the lock, and then a reader <em>R2</em> requests access. It would be unfair for <em>R2</em> to jump in immediately, ahead of <em>W</em>; if that happened often enough, <em>W</em> would 
<a href=https://en.wikipedia.org/wiki/Resource_starvation rel=noopener>starve</a>. Instead, <em>W</em> should start as soon as possible. This is the motivation for the <strong>second readers–writers problem</strong>, in which the constraint is added that <em>no writer, once added to the queue, shall be kept waiting longer than absolutely necessary</em>. This is also called <strong>writers-preference</strong>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>readcount</span><span class=p>,</span> <span class=n>writecount</span><span class=p>;</span>                   <span class=c1>//(initial value = 0)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semaphore</span> <span class=n>rmutex</span><span class=p>,</span> <span class=n>wmutex</span><span class=p>,</span> <span class=n>readTry</span><span class=p>,</span> <span class=n>resource</span><span class=p>;</span> <span class=c1>//(initial value = 1)
</span></span></span><span class=line><span class=cl><span class=c1>//READER
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>reader</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>ENTRY</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>readTry</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                 <span class=c1>//Indicate a reader is trying to enter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rmutex</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                  <span class=c1>//lock entry section to avoid race condition with other readers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>readcount</span><span class=o>++</span><span class=p>;</span>                 <span class=c1>//report yourself as a reader
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>readcount</span> <span class=o><mark></span> <span class=mi>1</span><span class=p>)</span>          <span class=c1>//checks if you are first reader
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>resource</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>              <span class=c1>//if you are first reader, lock  the resource
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rmutex</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                  <span class=c1>//release entry section for other readers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>readTry</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                 <span class=c1>//indicate you are done trying to access the resource
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=n>CRITICAL</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>//reading is performed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=n>EXIT</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>rmutex</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                  <span class=c1>//reserve exit section - avoids race condition with readers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>readcount</span><span class=o>--</span><span class=p>;</span>                 <span class=c1>//indicate you&#39;re leaving
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>readcount</span> <span class=o></mark></span> <span class=mi>0</span><span class=p>)</span>          <span class=c1>//checks if you are last reader leaving
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>resource</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>              <span class=c1>//if last, you must release the locked resource
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rmutex</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                  <span class=c1>//release exit section for other readers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//WRITER
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>writer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>ENTRY</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>wmutex</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                  <span class=c1>//reserve entry section for writers - avoids race conditions
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>writecount</span><span class=o>++</span><span class=p>;</span>                <span class=c1>//report yourself as a writer entering
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>writecount</span> <span class=o><mark></span> <span class=mi>1</span><span class=p>)</span>         <span class=c1>//checks if you&#39;re first writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>readTry</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>               <span class=c1>//if you&#39;re first, then you must lock the readers out. Prevent them from trying to enter CS
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>wmutex</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                  <span class=c1>//release entry section
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>resource</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                <span class=c1>//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=n>CRITICAL</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//writing is performed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>resource</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                <span class=c1>//release file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;</span><span class=n>EXIT</span> <span class=n>Section</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>wmutex</span><span class=p>.</span><span class=n>P</span><span class=p>();</span>                  <span class=c1>//reserve exit section
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>writecount</span><span class=o>--</span><span class=p>;</span>                <span class=c1>//indicate you&#39;re leaving
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>writecount</span> <span class=o></mark></span> <span class=mi>0</span><span class=p>)</span>         <span class=c1>//checks if you&#39;re the last writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>readTry</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>               <span class=c1>//if you&#39;re last writer, you must unlock the readers. Allows them to try enter CS for reading
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>wmutex</span><span class=p>.</span><span class=n>V</span><span class=p>();</span>                  <span class=c1>//release exit section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#practice-problems><h2 id=practice-problems><span class=hanchor arialabel=Anchor># </span>Practice Problems</h2></a><p><img src=https://i.imgur.com/APBjxa2.png width=auto alt>
a.</p><ol><li>Mutual exclusion</li><li>Progression</li><li>Bounded waiting
b.</li></ol><ul><li>Mx not satisfied:<ul><li>P1: turn = 0, while(flag and turn <mark>0) <em>flag is false</em>, critical section</li><li>context switch</li><li>P2: flag = true, while(turn</mark> 1), critical section</li></ul></li><li>Progress is not satisfied. P1 can only run if flag = false but flag is only set to false after the critical section of P1.
<img src=https://i.imgur.com/9ZAwLZl.png width=auto alt>
a. False. If all instructions can complete in 1 cycle, there will not be instructions being executed halfway before context switch occurs. There are also other reasons for race condition, not only due to translation. If implementation using a temporary variable, a race condition can also occur.
b. True. If no context switch can occur during critical section, only 1 process will be in its critical section at one time.
c. False. Satisfies progress only means that 1 program will always be chosen to enter critical section. To satisfy bounded waiting, each program must have a chance to enter its critical section. A program where only 1 process always enter critical section while another is waiting indefinitely satisfies progress but not bounded waiting.
<img src=https://i.imgur.com/rpsqnqG.png width=auto alt>
hmm not too sure abt this question
idea:</li></ul><ol><li>use a boolean lock value initialized to false as a shared variable, and a register boolean as a flag</li><li>continuously try to swap <code>true</code> into the lock</li><li>if register becomes false, we got the lock</li><li>critical section</li><li>set the lock to false</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>while</span><span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=nx>register</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nf>while</span> <span class=p>(</span><span class=nx>register</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>lock</span><span class=p>,</span> <span class=nx>register</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>  <span class=c1>//entry section
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>critical</span> <span class=nx>section</span><span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=nx>lock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=nx>remainder</span> <span class=nx>section</span><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://i.imgur.com/lNZUTeX.png width=auto alt>
a. -4
b. -6. All <code>Wait(S)</code> runs before a single <code>Signal(S)</code>. Each process is added to blocked queue until OS chooses to execute a critical region.
c. 2. There can be at most 2 processes holding S simultaneously as 2 processes are able to complete <code>wait(S)</code> (<em>not blocked</em>) before the block list starts to increase.
<img src=https://i.imgur.com/Mu27bAq.png width=auto alt>
To ensure there is no deadlock, there should not be any nesting i.e. two semaphores are not acquired together:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=nx>A</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>apple</span><span class=o>++</span>
</span></span><span class=line><span class=cl><span class=nf>signal</span><span class=p>(</span><span class=nx>A</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>wait</span><span class=p>(</span><span class=nx>O</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>at</span> <span class=nx>least</span> <span class=mi>2</span> <span class=nx>oranges</span> <span class=nx>in</span> <span class=nx>basket</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=nx>oranges</span> <span class=o>+=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>signal</span><span class=p>(</span><span class=nx>O</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>wait</span><span class=p>(</span><span class=nx>A</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>apple</span><span class=o>--</span>	
</span></span><span class=line><span class=cl>	<span class=nf>signal</span><span class=p>(</span><span class=nx>A</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://i.imgur.com/wHtLNOo.png width=auto alt>
Identify critical section for each function and use TestAndSet to acquire lock into the section:
<img src=https://i.imgur.com/mEBJuch.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Wait</span><span class=p>(</span><span class=nx>S</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=nf>while</span> <span class=p>(</span><span class=nf>TestAndSet</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>lock</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=nx>S</span><span class=p>.</span><span class=nx>value</span><span class=o>--</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nx>S</span><span class=p>.</span><span class=nx>value</span> <span class=p>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>S</span><span class=p>.</span><span class=nx>L</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>S</span><span class=p>.</span><span class=nx>L</span><span class=p>,</span> <span class=nx>process</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>lock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nf>sleep</span><span class=p>(</span><span class=nx>process</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>lock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>Signal</span><span class=p>(</span><span class=nx>S</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>while</span> <span class=p>(</span><span class=nf>TestAndSet</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>lock</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=nx>S</span><span class=p>.</span><span class=nx>value</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nx>S</span><span class=p>.</span><span class=nx>value</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>p</span> <span class=p>=</span> <span class=nx>S</span><span class=p>.</span><span class=nx>L</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>lock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=c1>//add to ready queue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=nx>lock</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/2005-Operating-Systems/ data-ctx="Process Synchronization" data-src=/2005-Operating-Systems class=internal-link>2005 Operating Systems</a></li><li><a href=/Notes/Concurrency-Control/ data-ctx="Process Synchronization" data-src=/Notes/Concurrency-Control class=internal-link>Concurrency Control</a></li><li><a href=/Notes/Deadlocks/ data-ctx data-src=/Notes/Deadlocks class=internal-link>Deadlocks</a></li><li><a href=/Notes/Software-Model-Checking/ data-ctx="Dining Philosophers problem" data-src=/Notes/Software-Model-Checking class=internal-link>Software Model Checking</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://www.brendanang.dev/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Brendan Ang using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://www.brendanang.dev/>Home</a></li><li><a href=https://github.com/bbawj>Github</a></li></ul></footer></div></div></body></html>